/**
 * Tests for check-secrets cron job
 *
 * Task #17: Implement check-secrets cron job with reminder functionality
 *
 * Test Coverage:
 * - Authorization
 * - Secret querying logic
 * - Urgency calculation
 * - Reminder interval logic
 * - Check-in URL generation
 * - Email sending
 * - Failure handling and retry logic
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { POST } from '@/app/api/cron/check-secrets/route';
import { NextRequest } from 'next/server';

// Mock dependencies
vi.mock('@/lib/db/drizzle', () => ({
  db: {
    select: vi.fn(),
    insert: vi.fn(),
  },
}));

vi.mock('@/lib/email/email-service', () => ({
  sendReminderEmail: vi.fn(),
}));

vi.mock('@/lib/email/email-failure-logger', () => ({
  logEmailFailure: vi.fn(),
}));

import { db } from '@/lib/db/drizzle';
const { sendReminderEmail } = await import('@/lib/email/email-service');
const { logEmailFailure } = await import('@/lib/email/email-failure-logger');

describe('POST /api/cron/check-secrets', () => {
  let db: Awaited<ReturnType<typeof getDatabase>>;
  let testUser: { id: string; email: string; name: string };
  let testSecret: any;

  beforeAll(async () => {
    db = await getDatabase();
  });

  beforeEach(async () => {
    // Clear mocks
    vi.clearAllMocks();

    // Create test user
    const [user] = await db.insert(users).values({
      id: `test-user-${Date.now()}`,
      email: 'test@example.com',
      name: 'Test User',
    }).returning();
    testUser = user;

    // Default mock: email sending succeeds
    vi.mocked(sendReminderEmail).mockResolvedValue({
      success: true,
      messageId: 'test-message-id',
    });
  });

  afterEach(async () => {
    // Clean up test data
    if (testSecret?.id) {
      await db.delete(checkInTokens).where(eq(checkInTokens.secretId, testSecret.id));
      await db.delete(secrets).where(eq(secrets.id, testSecret.id));
    }
    if (testUser?.id) {
      await db.delete(users).where(eq(users.id, testUser.id));
    }
  });

  describe('Authorization', () => {
    it('should reject requests without authorization header', async () => {
      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Unauthorized');
    });

    it('should reject requests with invalid bearer token', async () => {
      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer invalid-token',
        },
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Unauthorized');
    });

    it('should accept requests with valid CRON_SECRET', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';
      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);

      expect(response.status).toBe(200);
    });
  });

  describe('Secret Querying Logic', () => {
    it('should only query active secrets', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      // Create an active secret and a paused secret
      const [activeSecret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Active Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: 'encrypted-share',
      }).returning();

      const [pausedSecret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Paused Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'paused',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = activeSecret; // For cleanup

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.remindersProcessed).toBeGreaterThanOrEqual(0);

      // Clean up paused secret
      await db.delete(secrets).where(eq(secrets.id, pausedSecret.id));
    });

    it('should not send reminders for secrets without serverShare', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      // Create a secret without serverShare
      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Incomplete Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: null,
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(sendReminderEmail).not.toHaveBeenCalled();
    });
  });

  describe('Urgency Calculation', () => {
    const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

    it('should calculate critical urgency for < 1 hour remaining', async () => {
      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Critical Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 30), // 30 minutes from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.urgencyLevel).toBe('critical');
      }
    });

    it('should calculate high urgency for 1h - 24h remaining', async () => {
      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'High Urgency Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 12), // 12 hours from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.urgencyLevel).toBe('high');
      }
    });

    it('should calculate medium urgency for 24h - 7d remaining', async () => {
      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Medium Urgency Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24 * 3), // 3 days from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.urgencyLevel).toBe('medium');
      }
    });

    it('should calculate low urgency for > 7d remaining', async () => {
      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Low Urgency Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24 * 10), // 10 days from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.urgencyLevel).toBe('low');
      }
    });
  });

  describe('Check-in URL Generation', () => {
    it('should generate valid check-in URL with token', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Test Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.checkInUrl).toMatch(/^https?:\/\/.+\/check-in\?token=.+$/);
      }
    });

    it('should create check-in token in database', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Test Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      // Verify token was created
      const tokens = await db.select()
        .from(checkInTokens)
        .where(eq(checkInTokens.secretId, secret.id));

      if (sendReminderEmail.mock.calls.length > 0) {
        expect(tokens.length).toBeGreaterThan(0);
      }
    });
  });

  describe('Email Sending', () => {
    it('should send reminder email with correct data', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Test Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24), // 1 day from now
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.userEmail).toBe(testUser.email);
        expect(reminderData.userName).toBe(testUser.name);
        expect(reminderData.secretTitle).toBe('Test Secret');
        expect(reminderData.checkInUrl).toBeDefined();
        expect(reminderData.urgencyLevel).toBeDefined();
      }
    });

    it('should include correct daysRemaining in reminder', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';
      const hoursRemaining = 48; // 2 days

      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Test Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * hoursRemaining),
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        const reminderData = sendReminderEmail.mock.calls[0][0];
        expect(reminderData.daysRemaining).toBeCloseTo(2, 1);
      }
    });
  });

  describe('Failure Handling', () => {
    it('should log email failure when sending fails', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      // Mock email sending failure
      vi.mocked(sendReminderEmail).mockResolvedValue({
        success: false,
        error: 'SendGrid API error',
        retryable: true,
      });

      const [secret] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Test Secret',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24),
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret;

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      await POST(req);

      if (sendReminderEmail.mock.calls.length > 0) {
        expect(logEmailFailure).toHaveBeenCalledWith(
          expect.objectContaining({
            emailType: 'reminder',
            recipient: testUser.email,
            errorMessage: expect.stringContaining('SendGrid'),
          })
        );
      }
    });

    it('should continue processing other secrets after a failure', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      // Create two secrets
      const [secret1] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Secret 1',
        recipientName: 'Recipient',
        recipientEmail: 'recipient@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24),
        serverShare: 'encrypted-share',
      }).returning();

      const [secret2] = await db.insert(secrets).values({
        userId: testUser.id,
        title: 'Secret 2',
        recipientName: 'Recipient',
        recipientEmail: 'recipient2@example.com',
        contactMethod: 'email',
        status: 'active',
        checkInDays: 30,
        nextCheckIn: new Date(Date.now() + 1000 * 60 * 60 * 24),
        serverShare: 'encrypted-share',
      }).returning();

      testSecret = secret1; // For cleanup (will also clean secret2 manually)

      // Mock: first call fails, second succeeds
      vi.mocked(sendReminderEmail)
        .mockResolvedValueOnce({
          success: false,
          error: 'Temporary failure',
          retryable: true,
        })
        .mockResolvedValueOnce({
          success: true,
          messageId: 'test-message-id-2',
        });

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.remindersProcessed).toBeGreaterThanOrEqual(0);

      // Clean up second secret
      await db.delete(secrets).where(eq(secrets.id, secret2.id));
    });

    it('should return error details on database failure', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      // Mock database error by using invalid authorization that passes auth but fails later
      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);

      // Should return 200 with stats even if some operations fail
      expect(response.status).toBe(200);
    });
  });

  describe('Response Format', () => {
    it('should return processing statistics', async () => {
      const cronSecret = process.env.CRON_SECRET || 'test-cron-secret';

      const req = new NextRequest('http://localhost:3000/api/cron/check-secrets', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${cronSecret}`,
        },
      });

      const response = await POST(req);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data).toHaveProperty('remindersProcessed');
      expect(data).toHaveProperty('remindersSent');
      expect(data).toHaveProperty('remindersFailed');
      expect(data).toHaveProperty('timestamp');
    });
  });
});
